#!/usr/bin/env node

const { program } = require('commander');
const chalk = require('chalk');
const { askQuestions } = require('../lib/utils')
const { packageType } = require('../lib/questions')
const { command, hasLocalChanged, resolve, exists, mkdir, touch, stat, isRemoteRegistry, readFile, writeFile, oraPromise, jsonFormat, rm, gitBranchIs } = require('../lib/utils.js');
// é»˜è®¤çš„vscodeé…ç½®
const SETTINGS_CONFIG = require('../.vscode/settings.json')
// éœ€è¦åˆ é™¤çš„æ–‡ä»¶
const DELETE_FILES = ['.eslintrc.json', '.eslintrc.yaml', '.eslintrc.js', '.prettierrc.js','.prettierignore']
// .gitignoreå¿½ç•¥çš„æ–‡ä»¶
const GIT_IGNORE = ['node_modules', '.DS_Store', 'dist']
const PACKAGE_INSTALLERS = {
  'npm': {
    command: 'npm',
    install: "npm install",
    uninstall: 'npm uninstall',
    suffix: '-D'
  },
  'yarn': {
    command: 'yarn',
    install: "yarn add",
    uninstall: 'yarn remove',
    suffix: '--dev'
  },
  'pnpm': {
    command: 'pnpm',
    install: "pnpm add",
    uninstall: 'pnpm remove',
    suffix: '-D'
  }
}

program
  .name('rich')
  .usage('install <plugin-name>')
  .on('--help', () => {
    console.log('  Examples:')
    console.log()
    console.log(chalk.gray('    # install rich\'s plugin'))
    console.log('    $ rich install eslint')
    console.log()
  })
  .on('exit', console.log)
  .parse(process.argv)

function help() {
  if (program.args.length < 1) return program.help()
}

help()

// const INSTALL_PLUGIN_NAME = program.args[0]; // å®‰è£…çš„æ’ä»¶åç§°ï¼Œä¾‹å¦‚: eslint

class Package {
  constructor () {
    this.packageJson = {};      // package.jsonæ–‡ä»¶è½¬å¯¹è±¡
  }

  /**
   * @description è¯»å–package.jsonæ–‡ä»¶
   */
  async readPackageJson () {
    const jsonStr = await readFile('package.json')
    this.packageJson = JSON.parse(jsonStr) || {}
    return this.packageJson;
  }

  /**
   * @description æ›´æ–°package.json
   * @param { newPackageJson: string } æ–°çš„ packagejson å¯¹è±¡
   * @returns 
   */
  updatePackageJson (newPackageJson) {
    this.packageJson = newPackageJson
    return writeFile('package.json', jsonFormat(newPackageJson))
  }

 /**
  * @description è·å– vue ç‰ˆæœ¬
  * @returns { number }
  */
  getVueVersion () {
    const version = this.packageJson?.['dependencies']?.['vue'] || ''
    return version ? version.match(/\d/)[0] : null
  }

  /**
   * @description åˆ é™¤ package.json ä¸­æŒ‡å®šçš„å±æ€§
   * @param key è¦åˆ é™¤çš„key
   */
  removeKey (key) {
    if (this.packageJson[key]) delete this.packageJson[key];
  }

  /**
   * @description åˆ é™¤ package.json ä¸­ eslintConfigå’Œprettier ä¸¤ä¸ªé…ç½®é¡¹
   */
  async removeConfigFromPackageJson () {
    const lastestPackageJson = await this.readPackageJson();
    ['eslintConfig', 'prettier'].forEach(this.removeKey.bind(this))
    return await this.updatePackageJson(lastestPackageJson)
  }
}

class FileOperator {
  /**
 * @description æ˜¯å¦åˆå§‹åŒ–äº† git
 * @returns Promise<Boolean>
 */
  static isInitGit () {
    return stat('.git')
  }

  /**
 * @description æ˜¯å¦åˆå§‹åŒ–äº† npm
 * @returns Promise<Boolean>
 */
  static isInitNpm () {
    return stat('package.json')
  }

  /**
   * @description æ˜¯å¦æœ‰.gitignoreæ–‡ä»¶
   * @returns 
   */
   static hasGitignore () {
    return stat('.gitignore')
  }
  
  /**
   * @description åˆ›å»º.gitignore æ–‡ä»¶
   * @param ignoreRegs 
   */
   static createGitIgnore = (ignoreRegs) => {
    return touch('.gitignore', jsonFormat(ignoreRegs))
  }

  /**
   * @description è·å– eslint é…ç½®æ¨¡æ¿å¯¹è±¡
   * @param { vueVersion: Number } vueç‰ˆæœ¬
  */
  static getESLintConfig (vueVersion) {
    const base = {
      extends: ["eslint:recommended"],
      rules: {}
    }
    if (vueVersion) {
      base.extends.push(Number(vueVersion) === 2 ? 'plugin:vue/recommended' : "plugin:vue/vue3-recommended")
    }
    base.extends.push("eslint-config-rich")
    return base;
  }


  /**
   * @description å†™å…¥vscode é…ç½®
  */
  static writeVsCodeConfig (settings) {
    return oraPromise(() => {
      if (!exists('.vscode')) mkdir('.vscode');
      return writeFile('.vscode/settings.json', stringFormat(settings))
    }, {text: 'é…ç½®vscode'})
  }

  /**
   * @description å†™å…¥é…ç½®åˆ°é…ç½®æ–‡ä»¶
   * @param { object } newObj å†™å…¥æ–‡ä»¶çš„å¯¹è±¡
   * @param { string } path é…ç½®æ–‡ä»¶è·¯å¾„
   */
  static writeConfigToFile  (newObj, path) {
    const content = jsonFormat(newObj)
    writeFile(path, content)
  }

  /**
   * @description åˆ é™¤ESLintå…¶ä½™çš„é…ç½®æ–‡ä»¶å’Œprettieré…ç½®
   * ä¾‹å¦‚ï¼š
   * .eslintrc.json
   * .eslintrc
   * .eslintrc.yaml
   */
  static writeESLintConfig (vueVersion , deleteFiles = []) {
    oraPromise(() => {
      // å¹¶å‘åˆ é™¤é…ç½®æ–‡ä»¶
      let promises = deleteFiles.reduce((promises, filePath) => promises.concat(rm(filePath)), [])
        .map(t => t.catch(() => {}))
      const eslintConfig = this.getESLintConfig(vueVersion)
      // å†™å…¥eslinté…ç½®
      promises.push(this.writeConfigToFile(eslintConfig, resolve('.eslintrc')))
      return Promise.all(promises)
    }, { text: 'é…ç½®ESLint' })
  }
}

class CommandOperator {
  constructor () {
    this.packageCommand = {};
  }

  /**
   * @description åˆå§‹åŒ–å®‰è£…å™¨
   * @param { installers: Object } å®‰è£…å™¨ 
   */
  async init (installers) {
    let answer = await askQuestions([packageType])
    this.packageCommand = installers[answer.packtool]
  }
  /**
   * @description å®‰è£…ä¾èµ–
   * @param { string } packtool åŒ…ç®¡ç†å·¥å…·
   * @param { Array } plugins éœ€è¦å®‰è£…çš„ä¾èµ–
   */
  installPlugins (plugins) {
    const { packageCommand } = this
    return plugins.length
      ? command(`${packageCommand.install} ${plugins.join(' ')} ${packageCommand.suffix}`)
      : Promise.resolve()
  }

  /**
   * @description å¸è½½ä¾èµ–
   * @param plugins 
   */
  uninstallPlugins (plugins) {
    return plugins.length 
      ? command(`${this.packageCommand.uninstall} ${plugins.join(' ')}`) 
      : Promise.resolve()
  }

  /**
   * @description ä½¿ç”¨eslintæ ¼å¼åŒ–ä»£ç 
   */
  formatCodeByEslint () {
    return oraPromise(() => command('npx eslint --fix --ext .js,.vue,.ts'), {text: 'æ ¼å¼åŒ–ä»£ç '})
      .catch(() => {
        console.log(chalk.red('ESLintè¯­æ³•é”™è¯¯æ— æ³•è‡ªåŠ¨ä¿®å¤ï¼Œè¯·æ‰‹åŠ¨ä¿®å¤æˆ–åœ¨.eslintrc.jsä¸­å¿½ç•¥è§„åˆ™'))
        console.log(chalk.green('ä¿®å¤åè¯·ç»§ç»­æ‰§è¡Œ `rich lint` è¿›è¡Œæ ¡éªŒ'))
        process.exit()
      })
  }

  /**
   * @description commit ä»£ç 
   * @param { msg: string } æäº¤çš„message 
   */
  static async commit (msg) {
    await command('git add .')
    await command(`git commit -m "${msg}"`)
  }
}

/**
 * @description åˆå§‹åŒ–npm
 */
async function initNPM () {
  if (!await FileOperator.isInitNpm()) {
    await command(`npm init -y`);
    return true
  }
  return false
}

/**
 * @description åˆå§‹åŒ–git
 */
async function initGit () {
  const promises = []
  const [isInitGit, hasGitignore] = await Promise.all([
    FileOperator.isInitGit(),
    FileOperator.hasGitignore()
  ])
  if (hasGitignore && isInitGit) return false
  if (!hasGitignore) promises.push(FileOperator.createGitIgnore(GIT_IGNORE));        // ä¸å­˜åœ¨.gitignoreæ–‡ä»¶
  if (!isInitGit) promises.push(command('git init'));                               // æ²¡åˆå§‹åŒ–git

  await Promise.all(promises)
  return true
}

const main = async () => {
  const [isNotInitNpm, isNotInitGit] = await Promise.all([initNPM(), initGit()])

  // å¦‚æœæ²¡æœ‰åˆå§‹åŒ– npm å’Œ gitï¼Œåˆå§‹åŒ–å®Œåå¿…é¡»è¿›è¡Œä¸€æ¬¡æäº¤ã€‚å¦åˆ™æ‰§è¡Œ git stash ä¼šæŠ¥é”™ï¼šæ‚¨å°šæœªå»ºç«‹åˆå§‹æäº¤
  if (isNotInitNpm || isNotInitGit) {
    await CommandOperator.commit('init git and npm')
  }
  // æœ¬åœ°æ˜¯å¦æœ‰ä¿®æ”¹ï¼Œå¦‚æœæœ‰åˆ™æš‚å­˜
  if (await hasLocalChanged()) {
    console.log(chalk.green('æœ¬åœ°æœ‰ä¿®æ”¹ä½†æœªæäº¤çš„æ–‡ä»¶, å·²ä¸ºä½ è¿›è¡Œæœ¬åœ°æš‚å­˜'))
    await oraPromise(async () => {
      await command('git add .')
      await command(`git stash push -m "rich-flow stash your code at ${new Date().toLocaleString()}"`)
    }, {text: 'æš‚å­˜ä»£ç '})
  }
  
   // åˆ‡æ¢åˆ°masteråˆ†æ”¯
   if (!await gitBranchIs('master')) {
    await oraPromise(() => command('git checkout master'), {text: 'åˆ‡æ¢ master'})
  }

  // å¦‚æœæ˜¯è¿œç¨‹ä»“åº“ï¼Œæ‹‰å–æ›´æ–°
  if (await isRemoteRegistry()) {
    await oraPromise(() => command('git pull'), {text: 'æ‹‰å–æ›´æ–°'})
  }
  // åˆ›å»ºæ ¼å¼åŒ–åˆ†æ”¯
  await oraPromise(() => command('git checkout -b standard'), {text: 'åˆ›å»º standard åˆ†æ”¯'})

  const packageIns = new Package()

  await packageIns.readPackageJson()
  const commandIns = new CommandOperator()
  await commandIns.init(PACKAGE_INSTALLERS)
  const installPlugins = ['eslint-config-rich', 'eslint', 'eslint-plugin-vue']
  const prettierPlugins = Object.keys(packageIns.packageJson?.['devDependencies'] ?? []).filter(t => /prettier|eslint/.test(t))

  await oraPromise(async () => {
    await commandIns.uninstallPlugins(prettierPlugins)
    await commandIns.installPlugins(installPlugins)
    await packageIns.removeConfigFromPackageJson()
  }, {text: 'é…ç½®ä¾èµ–'})


  const vueVersion = packageIns.getVueVersion()

  await Promise.all([
    FileOperator.writeESLintConfig(vueVersion, DELETE_FILES),
    FileOperator.writeVsCodeConfig(SETTINGS_CONFIG)
  ])

  // æ ¼å¼åŒ–ä»£ç 
  await commandIns.formatCodeByEslint()
  
  await CommandOperator.commit('ci: install eslint and format')
  console.log(chalk.green('ğŸ‰å®‰è£…æˆåŠŸ, è¯·åˆ° standard åˆ†æ”¯æŸ¥çœ‹æœ€æ–°ä¸€æ¬¡çš„ä¿®æ”¹'))
}

main()









